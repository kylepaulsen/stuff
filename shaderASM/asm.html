<html>
<head>
<title>Pixel Vision</title>
<style>
body {
    font-family: monospace;
}
textarea {
    width: 150px;
    height: 400px;
    border: 1px solid #000;
}
td {
    vertical-align: top;
}
table {
    margin: 20px 0;
}
</style>
</head>
<body>

<canvas id="canvas"></canvas><br>
<table>
    <tr><td>
        <textarea id="asmTextarea"></textarea>
    </td><td>
        <b>def</b> &lt;number> <i>Create a number and store it in the register.</i><br>
        <b>loa</b> &lt;memory location> <i>Load a memory location into the register.</i><br>
        <b>set</b> &lt;memory location> <i>Set a memory location to the value of the register.</i><br>
        <b>jmp</b> &lt;#label> <i>Jump to the label.</i><br>
        <b>jeq</b> &lt;memory location> &lt;#label> <i>If the register matches the value at this memory location, jump to the label.</i><br>
        <b>jlt</b> &lt;memory location> &lt;#label> <i>If the register is less than the value at this memory location, jump to the label.</i><br>
        <b>add</b> &lt;memory location> <i>Add the value at the memory location to the register.</i><br>
        <b>sub</b> &lt;memory location> <i>Subtract the value at the memory location to the register.</i><br>
        <b>mul</b> &lt;memory location> <i>Multiply the value at the memory location to the register.</i><br>
        <b>div</b> &lt;memory location> <i>Divide the value at the memory location to the register.</i><br>
        <b>dis</b> &lt;memory location> <i>Find the distance (absolute value of sub) of the value at the memory location and the register and store it in the register.</i><br>
        <b>mod</b> &lt;memory location> <i>Find the remainder of the register divided by the value at the memory location and store it in the register.</i><br>
        <b>out</b> <i>Send the pixel to the canvas.</i><br><br>
        The first 7 memory locations are: the register (0), red (r) (1), green (g) (2), blue (b) (3), x (x) (4), y (y) (5), time (t) (6)<br>
        Memory locations 7-15 are free.
    </td></tr>
</table>
<button id="runBtn">Run</button>

<script src="vendor/gif.js"></script>

<script>
    const canvas = document.querySelector('#canvas');
    const asmTextarea = document.querySelector('#asmTextarea');
    const runBtn = document.querySelector('#runBtn');
    let initWidth = 256;
    let initHeight = 256;
    let width = initWidth;
    let height = initHeight;
    let imgDataObj;
    let imgData;
    let imgDataSize;
    let frame;
    let requestedFrame;

    canvas.width = initWidth;
    canvas.height = initHeight;
    const ctx = canvas.getContext('2d');
    ctx.fillRect(0, 0, width, height);

    const CREATE_INS = 0;
    const READ_INS = 1;
    const STORE_INS = 2;
    const OUT_INS = 3;
    const JUMP_INS = 4;
    const JUMPEQ_INS = 5;
    const JUMPLT_INS = 6;
    const ADD_INS = 7;
    const SUB_INS = 8;
    const MULT_INS = 9;
    const DIV_INS = 10;
    const DIST_INS = 11;
    const MOD_INS = 12;
    const compileInsts = {
        def: function(val) {
            return [CREATE_INS, parseInt(val)];
        },
        loa: function(loc) {
            return [READ_INS, parseInt(loc)];
        },
        set: function(loc) {
            return [STORE_INS, parseInt(loc)];
        },
        out: function() {
            return [OUT_INS];
        },
        jmp: function(label) {
            return [JUMP_INS, label];
        },
        jeq: function(loc, label) {
            return [JUMPEQ_INS, parseInt(loc), label];
        },
        jlt: function(loc, label) {
            return [JUMPLT_INS, parseInt(loc), label];
        },
        add: function(loc) {
            return [ADD_INS, parseInt(loc)];
        },
        sub: function(loc) {
            return [SUB_INS, parseInt(loc)];
        },
        mul: function(loc) {
            return [MULT_INS, parseInt(loc)];
        },
        div: function(loc) {
            return [DIV_INS, parseInt(loc)];
        },
        dis: function(loc) {
            return [DIST_INS, parseInt(loc)];
        },
        mod: function(loc) {
            return [MOD_INS, parseInt(loc)];
        }
    };

    const varsToLoc = function(str) {
        if (!str) {
            return;
        }
        if (str[0] === '#') {
            return str;
        }
        str = str.replace('r', '1');
        str = str.replace('g', '2');
        str = str.replace('b', '3');
        str = str.replace('x', '4');
        str = str.replace('y', '5');
        str = str.replace('t', '6');
        return str;
    }

    const compile = function() {
        let insts = [];
        let asm = asmTextarea.value.toLowerCase().replace(/\/\/[^\n]*/g, '');
        while (asm.indexOf('  ') > -1) {
            asm = asm.replace(/  /g, ' ');
        }
        let nextLabel;
        const lines = asm.split('\n');
        lines.forEach(function(line) {
            line = line.trim();
            const lineParts = line.split(' ');
            const inst = lineParts[0];
            const instFunc = compileInsts[inst];
            if (instFunc) {
                const instData = {inst: instFunc(varsToLoc(lineParts[1]), lineParts[2])};
                if (nextLabel) {
                    instData.label = nextLabel;
                    nextLabel = undefined;
                }
                insts.push(instData);
            } else if (inst[0] === '#' && inst.length > 1) {
                nextLabel = inst;
            }
        });
        const label2line = {};
        insts.forEach(function(instObj, idx) {
            if (instObj.label) {
                label2line[instObj.label] = idx;
            }
        });
        insts = insts.map(function(instObj) {
            const inst = instObj.inst;
            if (inst[0] === JUMP_INS) {
                const line = label2line[inst[1]];
                if (line === undefined) {
                    const err = 'Err: No such label: ' + inst[1];
                    alert(err);
                    throw new Error(err);
                }
                inst[1] = line;
            } else if (inst[0] === JUMPEQ_INS || inst[0] === JUMPLT_INS) {
                const line = label2line[inst[2]];
                if (line === undefined) {
                    const err = 'Err: No such label: ' + inst[2];
                    alert(err);
                    throw new Error(err);
                }
                inst[2] = line;
            }
            return inst;
        });
        cpuData.instructions = insts;
    };

    const compileAndRun = function() {
        reset();
        compile();
        run();
    };

    const reset = function() {
        stop();
        width = canvas.width;
        height = canvas.height;
        ctx.fillRect(0, 0, width, height);
        imgDataObj = ctx.getImageData(0, 0, width, height);
        imgData = imgDataObj.data;
        imgDataSize = imgData.length;
        frame = 0;
    };

    const MAXMEM = 16;
    const MAX_ALLOWED_INST = 999;
    const cpuData = {
        maxMem: MAXMEM,
        instructions: [],
        mem: new Uint8Array(MAXMEM),
        instructionPointer: 0
    };

    const stop = function() {
        if (requestedFrame) {
            cancelAnimationFrame(requestedFrame);
            requestedFrame = undefined;
        }
    };

    const run = function() {
        //console.time('render time');
        // using var to help V8 not bail out!
        var heightM1 = height - 1
        var x = 0;
        var y = heightM1;
        var idx = 0;
        var err;
        cpuData.mem = new Uint8Array(cpuData.maxMem);

        while (idx < imgDataSize) {
            var mem = cpuData.mem;
            cpuData.instructionPointer = 0;

            // feed in initial data.
            mem[1] = imgData[idx];
            mem[2] = imgData[idx + 1];
            mem[3] = imgData[idx + 2];
            mem[4] = x;
            mem[5] = y;
            mem[6] = frame;

            var instructionsSinceLastPixelOut = 0;
            var nextInst = cpuData.instructions[cpuData.instructionPointer++];
            while (nextInst && nextInst[0] !== OUT_INS) {
                switch (nextInst[0]) {
                    case CREATE_INS:
                        mem[0] = nextInst[1];
                        break;
                    case READ_INS:
                        mem[0] = mem[nextInst[1]];
                        break;
                    case STORE_INS:
                        mem[nextInst[1]] = mem[0];
                        break;
                    case JUMP_INS:
                        cpuData.instructionPointer = nextInst[1];
                        break;
                    case JUMPEQ_INS:
                        if (mem[0] === mem[nextInst[1]]) {
                            cpuData.instructionPointer = nextInst[2];
                        }
                        break;
                    case JUMPLT_INS:
                        if (mem[0] < mem[nextInst[1]]) {
                            cpuData.instructionPointer = nextInst[2];
                        }
                        break;
                    case ADD_INS:
                        mem[0] = mem[0] + mem[nextInst[1]];
                        break;
                    case SUB_INS:
                        mem[0] = mem[0] - mem[nextInst[1]];
                        break;
                    case MULT_INS:
                        mem[0] = mem[0] * mem[nextInst[1]];
                        break;
                    case DIV_INS:
                        mem[0] = mem[0] / mem[nextInst[1]];
                        break;
                    case DIST_INS:
                        mem[0] = Math.abs(mem[0] - mem[nextInst[1]]);
                        break;
                    case MOD_INS:
                        mem[0] = mem[0] % mem[nextInst[1]];
                        break;
                }
                if (instructionsSinceLastPixelOut > MAX_ALLOWED_INST) {
                    err = 'Might be in infinite loop! Emergency break!';
                    break;
                }
                nextInst = cpuData.instructions[cpuData.instructionPointer++];
                instructionsSinceLastPixelOut++;
            }
            if (!nextInst) {
                err = 'Didn\'t get a pixel out!';
            }
            if (err) {
                break;
            }
            instructionsSinceLastPixelOut = 0;

            var newIdx = 4 * ((heightM1 - mem[5]) * width + mem[4]);
            imgData[newIdx] = mem[1];
            imgData[newIdx + 1] = mem[2];
            imgData[newIdx + 2] = mem[3];
            imgData[newIdx + 3] = 255;
            frame = mem[6];

            x++;
            if (x >= width) {
                x = 0;
                y--;
            }
            idx = idx + 4;
        }

        if (err) {
            alert(err);
            throw new Error(err);
        }

        ctx.putImageData(imgDataObj, 0, 0);
        //console.timeEnd('render time');
        frame++;

        requestedFrame = requestAnimationFrame(run);
    };

    const nextFrame = function() {
        if (!imgDataObj) {
            reset();
        }
        if (!requestedFrame) {
            run();
            stop();
        }
    };

    function saveGif(numFrames, delay, quality) {
        console.log('saveGif(numFrames, delay_in_ms, quality) // lower quality is better.');
        numFrames = numFrames === undefined ? 30 : numFrames;
        delay = delay === undefined ? 30 : delay;
        quality = quality === undefined ? 1 : quality;
        const cores = navigator.hardwareConcurrency || 1;

        const gif = new GIF({
            workers: Math.min(cores, 16),
            quality: 1,
            width: 256,
            height: 256,
            workerScript: 'vendor/gif.worker.js'
        });

        compile();
        stop();
        reset();
        while (numFrames-- > 0) {
            nextFrame();
            gif.addFrame(ctx, {copy: true, delay: delay});
        }

        gif.on('finished', function(blob) {
            window.open(URL.createObjectURL(blob));
        });

        gif.render();
    }

    runBtn.addEventListener('click', compileAndRun);

</script>

</body>
</html>
